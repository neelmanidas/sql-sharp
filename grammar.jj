PARSER_BEGIN(SQLParser)
class SQLParser {}
PARSER_END(SQLParser)

SKIP : {
	<"--" (["a"-"z"])* ("\n" | "\r" | "\r\n")>
    |	" "
    |	"\t"
    |	"\n"
}

TOKEN : {
	< SELECT: "SELECT">
    |	< FROM: "FROM">
    |	< WHERE: "WHERE">
    |	< GROUPBY: "GROUP BY">
    |	< ORDERBY: "ORDER BY">
    |	< comma: ",">
    |	< identifier: ["a"-"z"](["a"-"z"] | ["0"-"9"])* >
    |	< asterisk: "*">
    |	< AS: "AS">
    |	< leftparen: "(">
    |	< rightparen: ")">
    |   < setfunctiontype: "AVG" | "MAX" | "MIN" | "SUM" | "COUNT">
    |	< #digit: ["0"-"9"] >
    |	< #integer: (<digit>)+ >
    |	< #real: ( <digit> )+ "." ( <digit> )+ >
    |   < number: ( "+" | "-" )? ( <integer> | <real> ) >
    |	< OR: "OR">
    |	< AND: "AND">
    |	<semicolon: ";">
    |	< IS: "IS">
    |	< NOT: "NOT">
    |	< #equalsoperator: "=" >
    |	< #lessthanoperator: "<" >
    |	< #greaterthanoperator: ">" >
    |	<compop: <equalsoperator> | <lessthanoperator> <greaterthanoperator> | <lessthanoperator> | <greaterthanoperator> | <lessthanoperator> <equalsoperator> | <greaterthanoperator> <equalsoperator> >
    |	< ASC: "ASC" >
    |	< DESC: "DESC" >
}

void Prog() :
{}
{ queryList() <EOF> }

void queryList() :
{}
{ querySpecification() ( querySpecification() )* }

void querySpecification() :
{}
{ select() selectList() from() identifier() [ where() booleanValueExpression() ] [ groupby() identifier() ] [ orderby() commonValueExpression() [ asc() | desc() ] ]";" }

void select() :
{}
{ <SELECT> }

void selectList() :
{}
{ asterisk() | derivedColumn() ( "," derivedColumn() )* }

void asterisk() :
{}
{ <asterisk> }

void derivedColumn() :
{}
{ commonValueExpression() [ [as()] identifier() ] }

void commonValueExpression() :
{}
{ "(" commonValueExpression() ")" | nonparenthesizedValueExpressionPrimary() }

void nonparenthesizedValueExpressionPrimary() :
{}
{ identifier() | <setfunctiontype> "(" commonValueExpression() ")" | <number> }

void as() :
{}
{ <AS> }

void from() :
{}
{ <FROM> }

void identifier() :
{}
{ <identifier> }

void where() :
{}
{ <WHERE> }

void booleanValueExpression() :
{}
{ booleanTerm() booleanValueExpressionPrime() }

void booleanValueExpressionPrime() :
{}
{ ( or() booleanTerm() booleanValueExpressionPrime() )? }

void or() :
{}
{ <OR> }

void booleanTerm() :
{}
{ booleanFactor() booleanTermPrime() }

void booleanTermPrime() :
{}
{ ( and() booleanFactor() booleanTermPrime())? }

void and() :
{}
{ <AND> }

void booleanFactor() : 
{}
{ [not()] boleanPredicand() [<compop> boleanPredicand()] }

void not() :
{}
{ <NOT> }

void boleanPredicand() :
{}
{ "(" booleanValueExpression() ")" | nonparenthesizedValueExpressionPrimary() }

void groupby() :
{}
{ <GROUPBY> }

void orderby() :
{}
{ <ORDERBY> }

void asc() :
{}
{ <ASC> }

void desc() :
{}
{ <DESC> }

